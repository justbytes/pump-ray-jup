{
  "version": 3,
  "sources": ["../index.ts", "../src/buy.ts", "../src/constants.js", "../src/utils.ts"],
  "sourcesContent": ["import { createSolanaClient, KeyPairSigner } from \"gill\";\nimport { loadKeypairSignerFromFile } from \"gill/node\";\n\nimport { pumpfunBuy } from \"./src/buy\";\n\nasync function main() {\n  // target mint address hardcoded for testing\n  const mint = \"BPHxyGCk3LAmQCMWUdgXQjadoee8N7b2LGoHXkhpump\";\n\n  // Creates connection to Solana\n  const connection = createSolanaClient({\n    urlOrMoniker: \"mainnet\",\n  });\n\n  // Load signer from config\n  const signer: KeyPairSigner = await loadKeypairSignerFromFile();\n\n  // For testing purposes\n  const amountInTokens = 100;\n  const maxSolToSpend = 0.0001;\n\n  // Test the buy\n  const response = await pumpfunBuy(\n    mint,\n    amountInTokens,\n    maxSolToSpend,\n    signer,\n    connection\n  );\n\n  console.log(\"Buy transaction response\", response);\n}\n\nmain();\n", "import {\n  AccountRole,\n  address,\n  createTransaction,\n  getExplorerLink,\n  getProgramDerivedAddress,\n  getSignatureFromTransaction,\n  IInstruction,\n  KeyPairSigner,\n  signTransactionMessageWithSigners,\n} from \"gill\";\nimport { SYSTEM_PROGRAM_ADDRESS } from \"gill/programs\";\nimport {\n  findAssociatedTokenPda,\n  getAssociatedTokenAccountAddress,\n  getCreateAssociatedTokenIdempotentInstruction,\n  TOKEN_PROGRAM_ADDRESS,\n} from \"gill/programs/token\";\n\n// Local Imports\nimport {\n  PUMPFUN_EVENT_AUTHORITY,\n  PUMPFUN_FEE_RECIPIENT,\n  PUMPFUN_GLOBAL,\n  PUMPFUN_PROGRAM_ID,\n  SYSVAR_RENT,\n} from \"./constants\";\nimport { formatPumpfunBuyAmount } from \"./utils\";\n\n/**\n *\n * @param {string} mint\n * @param {number} amountInTokens\n * @param {number} maxSolToSpend\n * @param {KeyPairSigner} signer\n * @param {any} connection\n * @returns\n */\nexport const pumpfunBuy = async (\n  mint: string,\n  amountInTokens: number,\n  maxSolToSpend: number,\n  signer: KeyPairSigner,\n  connection: any\n) => {\n  // Ensure we have a valid amount\n  // If one of these is set to zero it will be treated as a max value\n  if (maxSolToSpend === 0 && amountInTokens === 0) {\n    return {\n      success: false,\n      data: \"Both maxSolToSpend and amountInTokens cannot be zero\",\n    };\n  }\n\n  // Get the Uint8Array of the amounts for the instruction\n  const data: Uint8Array = formatPumpfunBuyAmount(\n    amountInTokens,\n    maxSolToSpend\n  );\n\n  // Get latest blockhash\n  const { value: latestBlockhash } = await connection.rpc\n    .getLatestBlockhash()\n    .send();\n\n  // Convert the mint address to type address for ease of use\n  const mintAddress = address(mint);\n\n  // Get the bondingCurve account\n  const [bondingCurve, _bondingBump] = await getProgramDerivedAddress({\n    seeds: [\"bonding-curve\", mintAddress],\n    programAddress: address(PUMPFUN_PROGRAM_ID),\n  });\n\n  console.log(\"Bonding Curve: \", bondingCurve);\n\n  // Get the bonding curve ata\n  const [bondingCurveAta, _bondingCurveBump] = await findAssociatedTokenPda({\n    mint: mintAddress,\n    owner: bondingCurve,\n    tokenProgram: TOKEN_PROGRAM_ADDRESS,\n  });\n\n  // Get the users ata for the mint\n  const userAta = await getAssociatedTokenAccountAddress(\n    mintAddress,\n    signer.address,\n    TOKEN_PROGRAM_ADDRESS\n  );\n\n  console.log(\"userATA: \", userAta);\n\n  // Instruction to get the users ata\n  const userAtaIx = getCreateAssociatedTokenIdempotentInstruction({\n    mint: mintAddress,\n    owner: signer.address,\n    payer: signer,\n    ata: userAta,\n  });\n\n  console.log(\"get user ata: \", userAtaIx);\n\n  // Buy pumpfun token instruction\n  const buyTokenIx: IInstruction = {\n    programAddress: address(PUMPFUN_PROGRAM_ID),\n    accounts: [\n      {\n        address: address(PUMPFUN_GLOBAL), // global address\n        role: AccountRole.READONLY,\n      },\n      {\n        address: address(PUMPFUN_FEE_RECIPIENT), // Pump fun fee recipent/account\n        role: AccountRole.WRITABLE,\n      },\n      { address: mintAddress, role: AccountRole.READONLY }, // Target mint token\n      {\n        address: address(bondingCurve), // Bonding curve\n        role: AccountRole.WRITABLE,\n      },\n      {\n        address: address(bondingCurveAta), // Bonding curve ata\n        role: AccountRole.WRITABLE,\n      },\n      {\n        address: address(userAta), // User ata\n        role: AccountRole.WRITABLE,\n      },\n      { address: signer.address, role: AccountRole.WRITABLE_SIGNER }, // User/signer\n      { address: address(SYSTEM_PROGRAM_ADDRESS), role: AccountRole.READONLY }, // System program\n      { address: address(TOKEN_PROGRAM_ADDRESS), role: AccountRole.READONLY }, // Token program\n      {\n        address: address(SYSVAR_RENT), // Sysvar Rent\n        role: AccountRole.READONLY,\n      },\n      {\n        address: address(PUMPFUN_EVENT_AUTHORITY), // Event authority\n        role: AccountRole.READONLY,\n      },\n      { address: address(PUMPFUN_PROGRAM_ID), role: AccountRole.READONLY }, // Pumpfun program id\n    ],\n    data,\n  };\n\n  // Build buy transaction\n  const tx = createTransaction({\n    feePayer: signer,\n    version: \"legacy\",\n    instructions: [userAtaIx, buyTokenIx],\n    latestBlockhash,\n  });\n\n  // Sign the transaction\n  const signedTransaction = await signTransactionMessageWithSigners(tx);\n\n  // Returns the explorer link to the transaction\n  console.log(\n    \"Explorer: \",\n    getExplorerLink({\n      transaction: getSignatureFromTransaction(signedTransaction),\n    })\n  );\n\n  // Make sure the transaction lands and return any results\n  try {\n    const results = await connection.sendAndConfirmTransaction(\n      signedTransaction\n    );\n    return { success: true, data: results };\n  } catch (error) {\n    console.log(\"Error with sending and confirming transaction\", error);\n    return { success: false, data: error };\n  }\n};\n", "export const PUMPFUN_PROGRAM_ID = \"6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P\";\nexport const PUMPFUN_GLOBAL = \"4wTV1YmiEkRvAtNtsSGPtUrqRYQMe5SKy2uB4Jjaxnjf\";\nexport const PUMPFUN_FEE_RECIPIENT =\n  \"FWsW1xNtWscwNmKv6wVsU1iTzRN6wmmk3MjxRP5tT7hz\";\nexport const PUMPFUN_EVENT_AUTHORITY =\n  \"Ce6TQqeHC9p8KetsN6JsjHK7UTZk7nasjjnr7XxXp9F1\";\n\nexport const SYSVAR_RENT = \"SysvarRent111111111111111111111111111111111\";\n", "export const formatPumpfunBuyAmount = (\n  amountInTokens: number,\n  maxSolToSpend: number\n) => {\n  // If maxSolToSpend is zero set maxSolToSpend slippage to 100%\n  // \"Buy the amountInTokens no matter the price\"\n  if (maxSolToSpend === 0) {\n    maxSolToSpend = -1;\n  }\n\n  // If amountInTokens is zero set amountInToken slippage to 100%\n  // \"Expect no minimum amount of tokens recieved for amount of maxsolToSpend\"\n  if (amountInTokens === 0) {\n    amountInTokens = -1;\n  }\n\n  // Create the data buffer\n  const dataBuffer = Buffer.alloc(24);\n  dataBuffer.write(\"66063d1201daebea\", \"hex\");\n  dataBuffer.writeBigUInt64LE(BigInt(amountInTokens), 8);\n  dataBuffer.writeBigUInt64LE(BigInt(maxSolToSpend), 16);\n\n  return new Uint8Array(dataBuffer);\n};\n\nformatPumpfunBuyAmount(0, 0);\n"],
  "mappings": "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",
  "names": []
}
